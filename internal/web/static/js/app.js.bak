// Claude Request Forwarder Web Interface JavaScript

class WebInterface {
    constructor() {
        this.refreshInterval = null;
        this.currentTab = 'overview';
        this.sseConnection = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 2000; // 2ç§’
        this.connectionStatus = 'disconnected';
        
        // æ•°æ®ç¼“å­˜ï¼Œç”¨äºå­˜å‚¨å„ä¸ªæ ‡ç­¾é¡µçš„æœ€æ–°æ•°æ®
        this.cachedData = {
            status: null,
            endpoints: null,
            groups: null,
            connections: null,
            logs: null,
            config: null
        };
        
        this.init();
    }

    init() {
        this.bindEvents();
        this.showTab('overview');
        // ç«‹å³åŠ è½½åˆå§‹æ•°æ®ï¼Œä¸ç­‰å¾…SSEè¿æ¥
        this.loadAllTabsData();
        this.createConnectionIndicator();
        // SSEè¿æ¥æ”¾åœ¨æœ€åå»ºç«‹
        this.setupSSE();
    }

    bindEvents() {
        // æ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabName = e.target.getAttribute('onclick').match(/'([^']+)'/)[1];
                this.showTab(tabName);
            });
        });
    }

    showTab(tabName) {
        // éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });

        // ç§»é™¤æ‰€æœ‰æ ‡ç­¾é¡µçš„æ´»åŠ¨çŠ¶æ€
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.classList.remove('active');
        });

        // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µ
        const selectedTab = document.getElementById(tabName);
        if (selectedTab) {
            selectedTab.classList.add('active');
        }

        // æ¿€æ´»å¯¹åº”çš„æ ‡ç­¾æŒ‰é’®
        document.querySelectorAll('.nav-tab').forEach(tab => {
            const tabTarget = tab.getAttribute('onclick')?.match(/'([^']+)'/)?.[1];
            if (tabTarget === tabName) {
                tab.classList.add('active');
            }
        });

        this.currentTab = tabName;
        
        // ä¼˜å…ˆä½¿ç”¨ç¼“å­˜æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰ç¼“å­˜åˆ™è¯·æ±‚API
        this.loadTabDataFromCache(tabName);
    }
    
    loadTabDataFromCache(tabName) {
        console.log('[Cache] å°è¯•ä»ç¼“å­˜åŠ è½½æ ‡ç­¾é¡µæ•°æ®:', tabName);
        
        switch (tabName) {
            case 'overview':
                // æ¦‚è§ˆé¡µé¢éœ€è¦ç»¼åˆæ•°æ®ï¼Œæ€»æ˜¯é‡æ–°åŠ è½½
                this.loadOverview();
                break;
            case 'endpoints':
                if (this.cachedData.endpoints) {
                    console.log('[Cache] ä½¿ç”¨ç¼“å­˜æ•°æ®æ˜¾ç¤ºendpoints');
                    const container = document.getElementById('endpoints-table');
                    if (container) {
                        container.innerHTML = this.generateEndpointsTable(this.cachedData.endpoints.endpoints);
                        this.bindEndpointEvents();
                    }
                } else {
                    console.log('[Cache] æ— ç¼“å­˜æ•°æ®ï¼Œè¯·æ±‚endpoints API');
                    this.loadEndpoints();
                }
                break;
            case 'groups':
                if (this.cachedData.groups) {
                    console.log('[Cache] ä½¿ç”¨ç¼“å­˜æ•°æ®æ˜¾ç¤ºgroups');
                    this.displayGroups(this.cachedData.groups);
                } else {
                    console.log('[Cache] æ— ç¼“å­˜æ•°æ®ï¼Œè¯·æ±‚groups API');
                    this.loadGroups();
                }
                break;
            case 'connections':
                if (this.cachedData.connections) {
                    console.log('[Cache] ä½¿ç”¨ç¼“å­˜æ•°æ®æ˜¾ç¤ºconnections');
                    const container = document.getElementById('connections-stats');
                    if (container) {
                        container.innerHTML = this.generateConnectionsStats(this.cachedData.connections);
                    }
                } else {
                    console.log('[Cache] æ— ç¼“å­˜æ•°æ®ï¼Œè¯·æ±‚connections API');
                    this.loadConnections();
                }
                break;
            case 'logs':
                // æ—¥å¿—æ•°æ®æ€»æ˜¯é‡æ–°åŠ è½½ä»¥è·å–æœ€æ–°å†…å®¹
                this.loadLogs();
                break;
            case 'config':
                // é…ç½®æ•°æ®æ€»æ˜¯é‡æ–°åŠ è½½ä»¥ç¡®ä¿æœ€æ–°
                this.loadConfig();
                break;
            default:
                // åå¤‡æ–¹æ¡ˆï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘
                this.loadTabData(tabName);
        }
    }

    loadAllTabsData() {
        // å¹¶è¡ŒåŠ è½½æ‰€æœ‰æ ‡ç­¾é¡µæ•°æ®ï¼ŒåŠ å¿«åˆå§‹æ˜¾ç¤ºé€Ÿåº¦
        Promise.all([
            this.loadOverview(),
            this.loadEndpoints(),
            this.loadGroups(),
            this.loadConnections(),
            this.loadLogs(),
            this.loadConfig()
        ]).catch(error => {
            console.error('åŠ è½½åˆå§‹æ•°æ®å¤±è´¥:', error);
        });
    }

    loadTabData(tabName) {
        switch (tabName) {
            case 'overview':
                this.loadOverview();
                break;
            case 'endpoints':
                this.loadEndpoints();
                break;
            case 'groups':
                this.loadGroups();
                break;
            case 'connections':
                this.loadConnections();
                break;
            case 'logs':
                this.loadLogs();
                break;
            case 'config':
                this.loadConfig();
                break;
        }
    }

    async loadOverview() {
        try {
            const [statusResponse, endpointsResponse, connectionsResponse, groupsResponse] = await Promise.all([
                fetch('/api/v1/status'),
                fetch('/api/v1/endpoints'),
                fetch('/api/v1/connections'),
                fetch('/api/v1/groups')
            ]);

            const status = await statusResponse.json();
            const endpoints = await endpointsResponse.json();
            const connections = await connectionsResponse.json();
            const groups = await groupsResponse.json();

            // æ›´æ–°æ¦‚è§ˆå¡ç‰‡
            document.getElementById('server-status').textContent = 
                status.status === 'running' ? 'ğŸŸ¢ è¿è¡Œä¸­' : 'ğŸ”´ å·²åœæ­¢';
            document.getElementById('uptime').textContent = status.uptime;
            document.getElementById('endpoint-count').textContent = endpoints.total;
            document.getElementById('total-requests').textContent = connections.total_requests;

            // æ›´æ–°æŒ‚èµ·è¯·æ±‚ä¿¡æ¯
            const suspendedData = connections.suspended || {};
            const suspendedElement = document.getElementById('suspended-requests');
            const suspendedRateElement = document.getElementById('suspended-success-rate');
            
            if (suspendedElement) {
                suspendedElement.textContent = `${suspendedData.suspended_requests || 0} / ${suspendedData.total_suspended_requests || 0}`;
            }
            
            if (suspendedRateElement) {
                const rate = suspendedData.success_rate || 0;
                suspendedRateElement.textContent = `æˆåŠŸç‡: ${rate.toFixed(1)}%`;
                suspendedRateElement.className = rate > 80 ? 'text-muted' : 'text-warning';
            }

            // æ›´æ–°å½“å‰æ´»åŠ¨ç»„ä¿¡æ¯
            const activeGroupElement = document.getElementById('active-group');
            const groupSuspendedInfoElement = document.getElementById('group-suspended-info');
            
            if (activeGroupElement) {
                activeGroupElement.textContent = groups.active_group || 'æœªçŸ¥';
            }
            
            if (groupSuspendedInfoElement && groups.total_suspended_requests > 0) {
                groupSuspendedInfoElement.textContent = `${groups.total_suspended_requests} ä¸ªæŒ‚èµ·è¯·æ±‚`;
                groupSuspendedInfoElement.style.display = 'block';
            } else if (groupSuspendedInfoElement) {
                groupSuspendedInfoElement.style.display = 'none';
            }

        } catch (error) {
            console.error('åŠ è½½æ¦‚è§ˆæ•°æ®å¤±è´¥:', error);
            this.showError('æ¦‚è§ˆæ•°æ®åŠ è½½å¤±è´¥');
        }
    }

    async loadEndpoints() {
        try {
            const response = await fetch('/api/v1/endpoints');
            const data = await response.json();

            // æ›´æ–°ç¼“å­˜
            this.cachedData.endpoints = data;
            console.log('[API] endpointsæ•°æ®å·²åŠ è½½å¹¶ç¼“å­˜');

            const container = document.getElementById('endpoints-table');
            if (data.endpoints && data.endpoints.length > 0) {
                container.innerHTML = this.generateEndpointsTable(data.endpoints);
                this.bindEndpointEvents();
            } else {
                container.innerHTML = '<p>æš‚æ— ç«¯ç‚¹æ•°æ®</p>';
            }
        } catch (error) {
            console.error('åŠ è½½ç«¯ç‚¹æ•°æ®å¤±è´¥:', error);
            this.showError('ç«¯ç‚¹æ•°æ®åŠ è½½å¤±è´¥');
        }
    }

    generateEndpointsTable(endpoints) {
        let html = `
            <table>
                <thead>
                    <tr>
                        <th>çŠ¶æ€</th>
                        <th>åç§°</th>
                        <th>URL</th>
                        <th>ä¼˜å…ˆçº§</th>
                        <th>ç»„</th>
                        <th>å“åº”æ—¶é—´</th>
                        <th>æœ€åæ£€æŸ¥</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody>
        `;

        endpoints.forEach(endpoint => {
            let statusClass, statusText;
            
            // æ ¹æ®never_checkedå­—æ®µå†³å®šçŠ¶æ€æ˜¾ç¤º
            if (endpoint.never_checked) {
                statusClass = 'status-never-checked';
                statusText = 'æœªæ£€æµ‹';
            } else if (endpoint.healthy) {
                statusClass = 'status-healthy';
                statusText = 'å¥åº·';
            } else {
                statusClass = 'status-unhealthy';
                statusText = 'ä¸å¥åº·';
            }
            
            html += `
                <tr>
                    <td>
                        <span class="status-indicator ${statusClass}"></span>
                        ${statusText}
                    </td>
                    <td>${endpoint.name}</td>
                    <td>${endpoint.url}</td>
                    <td>
                        <input type="number" 
                               class="priority-input" 
                               value="${endpoint.priority}" 
                               data-endpoint="${endpoint.name}"
                               min="1">
                    </td>
                    <td>${endpoint.group} (${endpoint.group_priority})</td>
                    <td>${endpoint.response_time}</td>
                    <td>${endpoint.last_check}</td>
                    <td>
                        <button class="btn btn-sm update-priority" data-endpoint="${endpoint.name}">
                            æ›´æ–°
                        </button>
                        <button class="btn btn-sm manual-health-check" data-endpoint="${endpoint.name}" title="æ‰‹åŠ¨å¥åº·æ£€æµ‹">
                            æ£€æµ‹
                        </button>
                    </td>
                </tr>
            `;
        });

        html += '</tbody></table>';
        return html;
    }

    bindEndpointEvents() {
        // ç»‘å®šä¼˜å…ˆçº§æ›´æ–°æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.update-priority').forEach(button => {
            button.addEventListener('click', async (e) => {
                const endpointName = e.target.dataset.endpoint;
                const priorityInput = document.querySelector(`input[data-endpoint="${endpointName}"]`);
                const newPriority = parseInt(priorityInput.value);

                if (newPriority < 1) {
                    alert('ä¼˜å…ˆçº§å¿…é¡»å¤§äºç­‰äº1');
                    return;
                }

                try {
                    const response = await fetch(`/api/v1/endpoints/${endpointName}/priority`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ priority: newPriority })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.showSuccess('ä¼˜å…ˆçº§æ›´æ–°æˆåŠŸ');
                        this.loadEndpoints(); // é‡æ–°åŠ è½½ç«¯ç‚¹æ•°æ®
                    } else {
                        this.showError(result.error || 'æ›´æ–°å¤±è´¥');
                    }
                } catch (error) {
                    console.error('æ›´æ–°ä¼˜å…ˆçº§å¤±è´¥:', error);
                    this.showError('æ›´æ–°ä¼˜å…ˆçº§å¤±è´¥');
                }
            });
        });

        // ç»‘å®šå›è½¦é”®æ›´æ–°äº‹ä»¶
        document.querySelectorAll('.priority-input').forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const updateButton = document.querySelector(`.update-priority[data-endpoint="${input.dataset.endpoint}"]`);
                    updateButton.click();
                }
            });
        });

        // ç»‘å®šæ‰‹åŠ¨å¥åº·æ£€æµ‹æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.manual-health-check').forEach(button => {
            button.addEventListener('click', async (e) => {
                const endpointName = e.target.dataset.endpoint;
                const originalText = e.target.innerHTML;
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                e.target.innerHTML = 'æ£€æµ‹ä¸­...';
                e.target.disabled = true;

                try {
                    const response = await fetch(`/api/v1/endpoints/${endpointName}/health-check`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });

                    const result = await response.json();
                    if (result.success) {
                        const healthText = result.healthy ? 'å¥åº·' : 'ä¸å¥åº·';
                        this.showSuccess(`æ‰‹åŠ¨æ£€æµ‹å®Œæˆ - ${endpointName}: ${healthText}`);
                        this.loadEndpoints(); // é‡æ–°åŠ è½½ç«¯ç‚¹æ•°æ®
                    } else {
                        this.showError(result.error || 'æ‰‹åŠ¨æ£€æµ‹å¤±è´¥');
                    }
                } catch (error) {
                    console.error('æ‰‹åŠ¨æ£€æµ‹å¤±è´¥:', error);
                    this.showError('æ‰‹åŠ¨æ£€æµ‹å¤±è´¥');
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    e.target.innerHTML = originalText;
                    e.target.disabled = false;
                }
            });
        });
    }

    async loadGroups() {
        try {
            const response = await fetch('/api/v1/groups');
            if (!response.ok) {
                throw new Error('è·å–ç»„ä¿¡æ¯å¤±è´¥');
            }
            const data = await response.json();
            this.displayGroups(data);
        } catch (error) {
            console.error('åŠ è½½ç»„ä¿¡æ¯å¤±è´¥:', error);
            document.getElementById('groups-container').innerHTML = 
                '<div class="error">âŒ åŠ è½½ç»„ä¿¡æ¯å¤±è´¥: ' + error.message + '</div>';
        }
    }

    displayGroups(data) {
        // æ˜¾ç¤ºç»„ä¿¡æ¯æ¦‚è¦å¡ç‰‡
        const groupInfoCards = document.getElementById('group-info-cards');
        if (data.groups && data.groups.length > 0) {
            groupInfoCards.innerHTML = data.groups.map(group => this.createGroupCard(group)).join('');
        } else {
            groupInfoCards.innerHTML = '<div class="info">ğŸ“¦ æ²¡æœ‰é…ç½®çš„ç»„</div>';
        }

        // æ˜¾ç¤ºç»„ç»Ÿè®¡æ¦‚è¦
        const groupsContainer = document.getElementById('groups-container');
        const summaryHtml = `
            <div class="groups-summary">
                <div class="summary-item">
                    <div class="summary-value">${data.total_groups || 0}</div>
                    <div class="summary-label">æ€»ç»„æ•°</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${data.active_groups || 0}</div>
                    <div class="summary-label">æ´»è·ƒç»„æ•°</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${data.groups ? data.groups.reduce((sum, g) => sum + g.healthy_endpoints, 0) : 0}</div>
                    <div class="summary-label">å¥åº·ç«¯ç‚¹</div>
                </div>
            </div>
        `;
        groupsContainer.innerHTML = summaryHtml;
    }

    createGroupCard(group) {
        const statusClass = group.in_cooldown ? 'cooldown' : (group.is_active ? 'active' : 'inactive');
        const statusText = group.status || (group.in_cooldown ? 'å†·å´ä¸­' : (group.is_active ? 'æ´»è·ƒ' : 'æœªæ¿€æ´»'));
        
        const cooldownInfo = group.in_cooldown && group.cooldown_remaining !== '0s' ? 
            `<div class="group-cooldown-info">ğŸ• å†·å´å‰©ä½™æ—¶é—´: ${group.cooldown_remaining}</div>` : '';

        return `
            <div class="group-info-card ${statusClass}">
                <div class="group-card-header">
                    <h3 class="group-name">${group.name}</h3>
                    <span class="group-status ${statusClass}">${statusText}</span>
                </div>
                <div class="group-details">
                    <div class="group-detail-item">
                        <div class="group-detail-label">ä¼˜å…ˆçº§</div>
                        <div class="group-detail-value group-priority">${group.priority}</div>
                    </div>
                    <div class="group-detail-item">
                        <div class="group-detail-label">ç«¯ç‚¹æ€»æ•°</div>
                        <div class="group-detail-value">${group.total_endpoints}</div>
                    </div>
                    <div class="group-detail-item">
                        <div class="group-detail-label">å¥åº·ç«¯ç‚¹</div>
                        <div class="group-detail-value group-endpoints-count">${group.healthy_endpoints}</div>
                    </div>
                    <div class="group-detail-item">
                        <div class="group-detail-label">ä¸å¥åº·ç«¯ç‚¹</div>
                        <div class="group-detail-value">${group.unhealthy_endpoints}</div>
                    </div>
                </div>
                <div class="group-actions">
                    <button class="group-btn btn-activate" 
                            onclick="webInterface.activateGroup('${group.name}')" 
                            ${!group.can_activate ? 'disabled' : ''}>
                        ğŸš€ æ¿€æ´»
                    </button>
                    <button class="group-btn btn-pause" 
                            onclick="webInterface.pauseGroup('${group.name}')" 
                            ${!group.can_pause ? 'disabled' : ''}>
                        â¸ï¸ æš‚åœ
                    </button>
                    <button class="group-btn btn-resume" 
                            onclick="webInterface.resumeGroup('${group.name}')" 
                            ${!group.can_resume ? 'disabled' : ''}>
                        â–¶ï¸ æ¢å¤
                    </button>
                </div>
                ${cooldownInfo}
            </div>
        `;
    }

    async activateGroup(groupName) {
        try {
            const response = await fetch(`/api/v1/groups/${groupName}/activate`, {
                method: 'POST'
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'æ¿€æ´»ç»„å¤±è´¥');
            }
            const result = await response.json();
            this.showNotification(result.message || `ç»„ ${groupName} å·²æ¿€æ´»`, 'success');
            // åˆ·æ–°ç»„æ•°æ®
            this.loadGroups();
        } catch (error) {
            console.error('æ¿€æ´»ç»„å¤±è´¥:', error);
            this.showNotification('æ¿€æ´»ç»„å¤±è´¥: ' + error.message, 'error');
        }
    }

    async pauseGroup(groupName) {
        try {
            const response = await fetch(`/api/v1/groups/${groupName}/pause`, {
                method: 'POST'
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'æš‚åœç»„å¤±è´¥');
            }
            const result = await response.json();
            this.showNotification(result.message || `ç»„ ${groupName} å·²æš‚åœ`, 'success');
            // åˆ·æ–°ç»„æ•°æ®
            this.loadGroups();
        } catch (error) {
            console.error('æš‚åœç»„å¤±è´¥:', error);
            this.showNotification('æš‚åœç»„å¤±è´¥: ' + error.message, 'error');
        }
    }

    async resumeGroup(groupName) {
        try {
            const response = await fetch(`/api/v1/groups/${groupName}/resume`, {
                method: 'POST'
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'æ¢å¤ç»„å¤±è´¥');
            }
            const result = await response.json();
            this.showNotification(result.message || `ç»„ ${groupName} å·²æ¢å¤`, 'success');
            // åˆ·æ–°ç»„æ•°æ®
            this.loadGroups();
        } catch (error) {
            console.error('æ¢å¤ç»„å¤±è´¥:', error);
            this.showNotification('æ¢å¤ç»„å¤±è´¥: ' + error.message, 'error');
        }
    }

    async loadConnections() {
        try {
            const response = await fetch('/api/v1/connections');
            const data = await response.json();

            // æ›´æ–°åŸºç¡€è¿æ¥ç»Ÿè®¡
            const container = document.getElementById('connections-stats');
            container.innerHTML = this.generateConnectionsStats(data);

            // æ›´æ–°æŒ‚èµ·è¯·æ±‚ç»Ÿè®¡
            this.updateSuspendedStats(data.suspended || {});
            
            // æ›´æ–°æŒ‚èµ·è¿æ¥åˆ—è¡¨
            this.updateSuspendedConnections(data.suspended_connections || []);
        } catch (error) {
            console.error('åŠ è½½è¿æ¥æ•°æ®å¤±è´¥:', error);
            this.showError('è¿æ¥æ•°æ®åŠ è½½å¤±è´¥');
        }
    }

    generateConnectionsStats(data) {
        return `
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value">${data.total_requests || 0}</div>
                    <div class="stat-label">æ€»è¯·æ±‚æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${data.active_connections || 0}</div>
                    <div class="stat-label">æ´»è·ƒè¿æ¥</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${data.successful_requests || 0}</div>
                    <div class="stat-label">æˆåŠŸè¯·æ±‚</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${data.failed_requests || 0}</div>
                    <div class="stat-label">å¤±è´¥è¯·æ±‚</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${data.average_response_time || '0s'}</div>
                    <div class="stat-label">å¹³å‡å“åº”æ—¶é—´</div>
                </div>
            </div>
        `;
    }

    async loadLogs() {
        try {
            const response = await fetch('/api/v1/logs');
            const data = await response.json();

            const container = document.getElementById('logs-container');
            if (data.logs && data.logs.length > 0) {
                container.innerHTML = this.generateLogsDisplay(data.logs);
            } else {
                container.innerHTML = '<p>æš‚æ— æ—¥å¿—æ•°æ®</p>';
            }
        } catch (error) {
            console.error('åŠ è½½æ—¥å¿—æ•°æ®å¤±è´¥:', error);
            this.showError('æ—¥å¿—æ•°æ®åŠ è½½å¤±è´¥');
        }
    }

    generateLogsDisplay(logs) {
        let html = '<div class="logs-container">';
        
        logs.forEach(log => {
            html += `
                <div class="log-entry">
                    <span class="log-timestamp">${log.timestamp}</span>
                    <span class="log-level ${log.level}">${log.level}</span>
                    <span class="log-message">${log.message}</span>
                </div>
            `;
        });

        html += '</div>';
        return html;
    }

    async loadConfig() {
        try {
            const response = await fetch('/api/v1/config');
            const data = await response.json();

            const container = document.getElementById('config-display');
            container.innerHTML = this.generateConfigDisplay(data);
        } catch (error) {
            console.error('åŠ è½½é…ç½®æ•°æ®å¤±è´¥:', error);
            this.showError('é…ç½®æ•°æ®åŠ è½½å¤±è´¥');
        }
    }

    generateConfigDisplay(config) {
        let html = '';

        Object.keys(config).forEach(section => {
            if (typeof config[section] === 'object' && config[section] !== null) {
                html += `<div class="config-section">`;
                html += `<h3>${section}</h3>`;
                
                Object.keys(config[section]).forEach(key => {
                    let value = config[section][key];
                    if (typeof value === 'object') {
                        value = JSON.stringify(value, null, 2);
                    }
                    
                    html += `
                        <div class="config-item">
                            <span class="config-key">${key}</span>
                            <span class="config-value">${value}</span>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
        });

        return html;
    }

    startAutoRefresh() {
        // SSEè¿æ¥å»ºç«‹åä¸å†éœ€è¦å®šæ—¶åˆ·æ–°
        // ä½†ä¸ºäº†å…¼å®¹æ€§ä¿ç•™ï¼Œåœ¨SSEè¿æ¥å¤±è´¥æ—¶ä½¿ç”¨
        if (this.connectionStatus === 'connected') {
            this.stopAutoRefresh();
            return;
        }
        
        // æ¯30ç§’è‡ªåŠ¨åˆ·æ–°å½“å‰æ ‡ç­¾é¡µæ•°æ®
        this.refreshInterval = setInterval(() => {
            if (this.connectionStatus !== 'connected') {
                this.loadTabData(this.currentTab);
            }
        }, 30000);
    }

    stopAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }

    showSuccess(message) {
        this.showNotification('âœ… ' + message, 'success');
    }

    showError(message) {
        this.showNotification('âŒ ' + message, 'error');
    }
    
    showInfo(message) {
        this.showNotification('â„¹ï¸ ' + message, 'info');
    }

    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        const colors = {
            success: 'var(--success-color, #10b981)',
            error: 'var(--error-color, #ef4444)',
            info: 'var(--info-color, #3b82f6)'
        };
        
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${colors[type]};
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 400px;
        `;
        
        document.body.appendChild(notification);
        
        const timeout = type === 'error' ? 5000 : 3000;
        setTimeout(() => {
            if (notification.parentNode) {
                document.body.removeChild(notification);
            }
        }, timeout);
    }

    // SSEç›¸å…³æ–¹æ³•
    setupSSE() {
        this.connectSSE();
    }

    connectSSE() {
        if (this.sseConnection) {
            this.sseConnection.close();
        }

        this.updateConnectionStatus('connecting');
        
        const clientId = this.getOrCreateClientId();
        const events = 'status,endpoint,group,connection,log,chart'; // è®¢é˜…çš„äº‹ä»¶ç±»å‹ï¼ŒåŒ…æ‹¬å›¾è¡¨äº‹ä»¶
        
        try {
            this.sseConnection = new EventSource(`/api/v1/stream?client_id=${clientId}&events=${events}`);
            
            this.sseConnection.onopen = () => {
                console.log('SSEè¿æ¥å·²å»ºç«‹');
                this.updateConnectionStatus('connected');
                this.reconnectAttempts = 0;
                this.stopAutoRefresh(); // åœæ­¢å®šæ—¶åˆ·æ–°
            };
            
            this.sseConnection.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleSSEMessage(data);
                } catch (error) {
                    console.error('è§£æSSEæ¶ˆæ¯å¤±è´¥:', error, event.data);
                }
            };
            
            // ç›‘å¬ç‰¹å®šäº‹ä»¶ç±»å‹
            ['status', 'endpoint', 'group', 'connection', 'log', 'config', 'chart'].forEach(eventType => {
                this.sseConnection.addEventListener(eventType, (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleSSEMessage(data, eventType);
                    } catch (error) {
                        console.error(`è§£æ${eventType}äº‹ä»¶å¤±è´¥:`, error);
                    }
                });
            });
            
            this.sseConnection.onerror = (event) => {
                console.error('SSEè¿æ¥é”™è¯¯:', event);
                this.updateConnectionStatus('error');
                this.handleSSEError();
            };
            
        } catch (error) {
            console.error('åˆ›å»ºSSEè¿æ¥å¤±è´¥:', error);
            this.updateConnectionStatus('error');
            this.handleSSEError();
        }
    }

    handleSSEMessage(data, eventType) {
        // æ ¹æ®äº‹ä»¶ç±»å‹æ›´æ–°ç›¸åº”çš„UI
        switch (eventType || data.type) {
            case 'status':
                this.updateStatusData(data);
                break;
            case 'endpoint':
                this.updateEndpointsData(data);
                break;
            case 'group':
                this.updateGroupsData(data);
                break;
            case 'connection':
                this.updateConnectionsData(data);
                break;
            case 'suspended':
                this.updateSuspendedData(data);
                break;
            case 'log':
                this.updateLogsData(data);
                break;
            case 'config':
                this.showInfo('é…ç½®å·²æ›´æ–°');
                if (this.currentTab === 'config') {
                    this.loadConfig();
                }
                break;
            case 'chart':
                this.updateChartData(data);
                break;
            default:
                console.log('æ”¶åˆ°SSEæ¶ˆæ¯:', data);
        }
    }

    handleSSEError() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * this.reconnectAttempts;
            
            console.log(`SSEé‡è¿å°è¯• ${this.reconnectAttempts}/${this.maxReconnectAttempts}ï¼Œ${delay}msåé‡è¯•`);
            this.updateConnectionStatus('reconnecting');
            
            setTimeout(() => {
                this.connectSSE();
            }, delay);
        } else {
            console.error('SSEé‡è¿å°è¯•å·²è¾¾ä¸Šé™ï¼Œåˆ‡æ¢åˆ°å®šæ—¶åˆ·æ–°æ¨¡å¼');
            this.updateConnectionStatus('failed');
            this.startAutoRefresh(); // å›é€€åˆ°å®šæ—¶åˆ·æ–°
        }
    }

    updateConnectionStatus(status) {
        this.connectionStatus = status;
        const indicator = document.getElementById('connection-indicator');
        if (indicator) {
            const statusInfo = this.getConnectionStatusInfo(status);
            indicator.className = `connection-indicator ${status}`;
            indicator.textContent = statusInfo.text;
            indicator.title = statusInfo.tooltip;
        }
    }

    getConnectionStatusInfo(status) {
        const statusMap = {
            'connected': { text: 'ğŸŸ¢', tooltip: 'SSEè¿æ¥å·²å»ºç«‹ï¼Œå®æ—¶æ›´æ–°ä¸­' },
            'connecting': { text: 'ğŸŸ¡', tooltip: 'æ­£åœ¨è¿æ¥...' },
            'reconnecting': { text: 'ğŸŸ ', tooltip: `é‡è¿ä¸­... (${this.reconnectAttempts}/${this.maxReconnectAttempts})` },
            'error': { text: 'ğŸ”´', tooltip: 'SSEè¿æ¥é”™è¯¯' },
            'failed': { text: 'âš«', tooltip: 'SSEè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨å®šæ—¶åˆ·æ–°' },
            'disconnected': { text: 'âšª', tooltip: 'æœªè¿æ¥' }
        };
        return statusMap[status] || statusMap['disconnected'];
    }

    createConnectionIndicator() {
        const header = document.querySelector('header');
        if (header) {
            const indicator = document.createElement('div');
            indicator.id = 'connection-indicator';
            indicator.className = 'connection-indicator disconnected';
            indicator.textContent = 'âšª';
            indicator.title = 'è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨';
            indicator.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                font-size: 20px;
                cursor: help;
            `;
            header.appendChild(indicator);
        }
    }

    getOrCreateClientId() {
        let clientId = localStorage.getItem('sse_client_id');
        if (!clientId) {
            clientId = 'client_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('sse_client_id', clientId);
        }
        return clientId;
    }

    // æ•°æ®æ›´æ–°æ–¹æ³•
    updateStatusData(data) {
        if (this.currentTab === 'overview') {
            if (data.status) document.getElementById('server-status').textContent = 
                data.status === 'running' ? 'ğŸŸ¢ è¿è¡Œä¸­' : 'ğŸ”´ å·²åœæ­¢';
            if (data.uptime) document.getElementById('uptime').textContent = data.uptime;
        }
    }

    updateEndpointsData(data) {
        // å§‹ç»ˆæ›´æ–°ç¼“å­˜æ•°æ®ï¼Œä¸ç®¡å½“å‰åœ¨å“ªä¸ªæ ‡ç­¾é¡µ
        if (data.endpoints) {
            this.cachedData.endpoints = data;
            console.log('[SSE] ç«¯ç‚¹æ•°æ®å·²æ›´æ–°åˆ°ç¼“å­˜:', data.endpoints.length, 'ä¸ªç«¯ç‚¹');
        }
        
        // å¦‚æœå½“å‰åœ¨endpointsæ ‡ç­¾é¡µï¼Œç«‹å³æ›´æ–°UI
        if (this.currentTab === 'endpoints' && data.endpoints) {
            const container = document.getElementById('endpoints-table');
            if (container) {
                container.innerHTML = this.generateEndpointsTable(data.endpoints);
                this.bindEndpointEvents();
                console.log('[UI] endpointsæ ‡ç­¾é¡µUIå·²æ›´æ–°');
            }
        }
        
        // æ›´æ–°æ¦‚è§ˆé¡µé¢çš„ç«¯ç‚¹æ•°é‡ï¼ˆå§‹ç»ˆæ›´æ–°ï¼‰
        if (data.total !== undefined) {
            const endpointCount = document.getElementById('endpoint-count');
            if (endpointCount && this.currentTab === 'overview') {
                endpointCount.textContent = data.total;
                console.log('[UI] æ¦‚è§ˆé¡µé¢ç«¯ç‚¹æ•°é‡å·²æ›´æ–°:', data.total);
            }
        }
    }

    updateGroupsData(data) {
        // å§‹ç»ˆæ›´æ–°ç¼“å­˜æ•°æ®
        if (data) {
            this.cachedData.groups = data;
            console.log('[SSE] ç»„æ•°æ®å·²æ›´æ–°åˆ°ç¼“å­˜');
            
            // æ›´æ–°æŒ‚èµ·è¯·æ±‚æç¤º
            this.updateGroupSuspendedAlert(data);
        }
        
        // å¦‚æœå½“å‰åœ¨groupsæ ‡ç­¾é¡µï¼Œç«‹å³æ›´æ–°UI
        if (this.currentTab === 'groups') {
            this.displayGroups(data);
            console.log('[UI] groupsæ ‡ç­¾é¡µUIå·²æ›´æ–°');
        }
    }

    updateConnectionsData(data) {
        // å§‹ç»ˆæ›´æ–°ç¼“å­˜æ•°æ®
        if (data) {
            this.cachedData.connections = data;
            console.log('[SSE] è¿æ¥æ•°æ®å·²æ›´æ–°åˆ°ç¼“å­˜');
        }
        
        // å¦‚æœå½“å‰åœ¨connectionsæ ‡ç­¾é¡µï¼Œç«‹å³æ›´æ–°UI
        if (this.currentTab === 'connections') {
            const container = document.getElementById('connections-stats');
            if (container) {
                container.innerHTML = this.generateConnectionsStats(data);
                console.log('[UI] connectionsæ ‡ç­¾é¡µUIå·²æ›´æ–°');
            }
            
            // æ›´æ–°æŒ‚èµ·è¯·æ±‚ç»Ÿè®¡
            if (data.suspended) {
                this.updateSuspendedStats(data.suspended);
            }
            
            // æ›´æ–°æŒ‚èµ·è¿æ¥åˆ—è¡¨
            if (data.suspended_connections) {
                this.updateSuspendedConnections(data.suspended_connections);
            }
        }
        
        // å¦‚æœåœ¨æ¦‚è§ˆé¡µé¢ï¼Œæ›´æ–°æŒ‚èµ·è¯·æ±‚ä¿¡æ¯
        if (this.currentTab === 'overview' && data.suspended) {
            const suspendedElement = document.getElementById('suspended-requests');
            const suspendedRateElement = document.getElementById('suspended-success-rate');
            
            if (suspendedElement) {
                suspendedElement.textContent = `${data.suspended.suspended_requests || 0} / ${data.suspended.total_suspended_requests || 0}`;
            }
            
            if (suspendedRateElement) {
                const rate = data.suspended.success_rate || 0;
                suspendedRateElement.textContent = `æˆåŠŸç‡: ${rate.toFixed(1)}%`;
                suspendedRateElement.className = rate > 80 ? 'text-muted' : 'text-warning';
            }
        }
    }
        
        // æ›´æ–°æ¦‚è§ˆé¡µé¢çš„è¯·æ±‚æ•°ï¼ˆå§‹ç»ˆæ›´æ–°ï¼‰
        if (data.total_requests !== undefined) {
            const totalRequests = document.getElementById('total-requests');
            if (totalRequests && this.currentTab === 'overview') {
                totalRequests.textContent = data.total_requests;
                console.log('[UI] æ¦‚è§ˆé¡µé¢è¯·æ±‚æ€»æ•°å·²æ›´æ–°:', data.total_requests);
            }
        }
    }

    updateSuspendedData(data) {
        console.log('[SSE] æ”¶åˆ°æŒ‚èµ·è¯·æ±‚äº‹ä»¶æ•°æ®:', data);
        
        // å¦‚æœåœ¨è¿æ¥æ ‡ç­¾é¡µï¼Œæ›´æ–°æŒ‚èµ·è¯·æ±‚ç»Ÿè®¡
        if (this.currentTab === 'connections') {
            if (data.current) {
                this.updateSuspendedStats(data.current);
            }
            if (data.suspended_connections) {
                this.updateSuspendedConnections(data.suspended_connections);
            }
        }
        
        // åœ¨æ¦‚è§ˆé¡µé¢æ›´æ–°æŒ‚èµ·è¯·æ±‚ç»Ÿè®¡
        if (this.currentTab === 'overview' && data.current) {
            const suspendedElement = document.getElementById('suspended-requests');
            const suspendedRateElement = document.getElementById('suspended-success-rate');
            
            if (suspendedElement) {
                suspendedElement.textContent = `${data.current.suspended_requests || 0} / ${data.current.total_suspended_requests || 0}`;
            }
            
            if (suspendedRateElement) {
                const rate = data.current.success_rate || 0;
                suspendedRateElement.textContent = `æˆåŠŸç‡: ${rate.toFixed(1)}%`;
                suspendedRateElement.className = rate > 80 ? 'text-muted' : 'text-warning';
            }
        }
        
        // æ˜¾ç¤ºæŒ‚èµ·è¯·æ±‚é€šçŸ¥
        if (data.current && data.current.suspended_requests > 0) {
            this.showNotification(`å½“å‰æœ‰ ${data.current.suspended_requests} ä¸ªæŒ‚èµ·è¯·æ±‚`, 'info');
        }
    }

    updateLogsData(data) {
        if (this.currentTab === 'logs' && data.logs) {
            const container = document.getElementById('logs-container');
            if (container) {
                // åœ¨ç°æœ‰æ—¥å¿—å‰é¢æ·»åŠ æ–°æ—¥å¿—
                const newLogHtml = this.generateLogsDisplay([data]);
                container.insertAdjacentHTML('afterbegin', newLogHtml);
                
                // é™åˆ¶æ—¥å¿—æ¡æ•°ï¼Œé¿å…é¡µé¢è¿‡è½½
                const logEntries = container.querySelectorAll('.log-entry');
                if (logEntries.length > 100) {
                    for (let i = 100; i < logEntries.length; i++) {
                        logEntries[i].remove();
                    }
                }
            }
        }
    }

    // æ›´æ–°å›¾è¡¨æ•°æ®
    updateChartData(data) {
        // é€šçŸ¥å›¾è¡¨ç®¡ç†å™¨å¤„ç†SSEæ›´æ–°
        if (window.chartManager) {
            try {
                // å¯ç”¨SSEæ›´æ–°æ¨¡å¼
                if (!window.chartManager.sseEnabled) {
                    window.chartManager.enableSSEUpdates();
                }
                
                // å‘é€å›¾è¡¨æ›´æ–°äº‹ä»¶åˆ°å›¾è¡¨ç®¡ç†å™¨
                const chartUpdateEvent = new CustomEvent('chartUpdate', {
                    detail: {
                        chart_type: data.chart_type,
                        data: data.data
                    }
                });
                document.dispatchEvent(chartUpdateEvent);
                
                console.log(`ğŸ“Š SSEå›¾è¡¨æ•°æ®æ›´æ–°: ${data.chart_type}`);
            } catch (error) {
                console.error('æ›´æ–°å›¾è¡¨æ•°æ®å¤±è´¥:', error);
                // å›é€€åˆ°ç›´æ¥æ›´æ–°æ¨¡å¼
                this.updateChartLegacy(data);
            }
        } else {
            console.warn('å›¾è¡¨ç®¡ç†å™¨æœªåˆå§‹åŒ–');
        }
    }

    // å…¼å®¹æ—§ç‰ˆå›¾è¡¨æ›´æ–°ï¼ˆä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼‰
    updateChartLegacy(data) {
        if (this.currentTab === 'charts' && window.chartManager) {
            try {
                const chartType = data.chart_type;
                const chartData = data.data;
                
                // æ ¹æ®å›¾è¡¨ç±»å‹æ›´æ–°å¯¹åº”çš„å›¾è¡¨
                const chartName = this.mapChartTypeToName(chartType);
                if (chartName && window.chartManager.charts.has(chartName)) {
                    const chart = window.chartManager.charts.get(chartName);
                    chart.data = chartData;
                    chart.update('none'); // æ— åŠ¨ç”»æ›´æ–°ï¼Œå®æ—¶æ€§æ›´å¥½
                }
            } catch (error) {
                console.error('å…¼å®¹æ¨¡å¼å›¾è¡¨æ›´æ–°å¤±è´¥:', error);
            }
        }
    }

    // æ˜ å°„å›¾è¡¨ç±»å‹åˆ°å†…éƒ¨åç§°
    mapChartTypeToName(chartType) {
        const mapping = {
            'request_trends': 'requestTrend',
            'response_times': 'responseTime', 
            'token_usage': 'tokenUsage',
            'endpoint_health': 'endpointHealth',
            'connection_activity': 'connectionActivity',
            'endpoint_performance': 'endpointPerformance'
        };
        return mapping[chartType] || chartType;
    }

    // æ¸…ç†èµ„æº
    destroy() {
        if (this.sseConnection) {
            this.sseConnection.close();
        }
        this.stopAutoRefresh();
    }

    // æ›´æ–°æŒ‚èµ·è¯·æ±‚ç»Ÿè®¡
    updateSuspendedStats(suspendedData) {
        const elements = {
            'current-suspended': suspendedData.suspended_requests || 0,
            'total-suspended': suspendedData.total_suspended_requests || 0,
            'successful-suspended': suspendedData.successful_suspended_requests || 0,
            'timeout-suspended': suspendedData.timeout_suspended_requests || 0,
            'suspended-success-rate-detail': `${(suspendedData.success_rate || 0).toFixed(1)}%`,
            'avg-suspended-time': suspendedData.average_suspended_time || '0ms'
        };

        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });
    }

    // æ›´æ–°æŒ‚èµ·è¿æ¥åˆ—è¡¨
    updateSuspendedConnections(connections) {
        const container = document.getElementById('suspended-connections-table');
        if (!container) return;

        if (connections.length === 0) {
            container.innerHTML = '<p>æ— æŒ‚èµ·è¿æ¥</p>';
            return;
        }

        let html = '<div class="suspended-connections-list">';
        connections.forEach(conn => {
            html += `
                <div class="suspended-connection-item">
                    <div class="connection-header">
                        <div class="connection-id">${conn.id}</div>
                        <div class="suspended-time">${conn.suspended_time}</div>
                    </div>
                    <div class="connection-details">
                        <div><strong>IP:</strong> ${conn.client_ip}</div>
                        <div><strong>ç«¯ç‚¹:</strong> ${conn.endpoint}</div>
                        <div><strong>æ–¹æ³•:</strong> ${conn.method}</div>
                        <div><strong>è·¯å¾„:</strong> ${conn.path}</div>
                        <div><strong>é‡è¯•æ¬¡æ•°:</strong> ${conn.retry_count}</div>
                        <div><strong>æŒ‚èµ·æ—¶é—´:</strong> ${conn.suspended_at}</div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        container.innerHTML = html;
    }

    // æ›´æ–°ç»„ç®¡ç†ç•Œé¢çš„æŒ‚èµ·æç¤º
    updateGroupSuspendedAlert(groupData) {
        const alertBanner = document.getElementById('group-suspended-alert');
        const alertMessage = document.getElementById('suspended-alert-message');
        
        if (!alertBanner || !alertMessage) return;

        const totalSuspended = groupData.total_suspended_requests || 0;
        const groupCounts = groupData.group_suspended_counts || {};

        if (totalSuspended > 0) {
            let message = `å½“å‰æœ‰ ${totalSuspended} ä¸ªæŒ‚èµ·è¯·æ±‚ç­‰å¾…å¤„ç†`;
            const suspendedGroups = Object.entries(groupCounts)
                .filter(([group, count]) => count > 0)
                .map(([group, count]) => `${group}(${count})`)
                .join(', ');
            
            if (suspendedGroups) {
                message += `ï¼Œæ¶‰åŠç»„: ${suspendedGroups}`;
            }
            
            alertMessage.textContent = message;
            alertBanner.style.display = 'flex';
        } else {
            alertBanner.style.display = 'none';
        }
    }
}

// å…¨å±€å‡½æ•°ç”¨äºHTMLä¸­çš„onclickäº‹ä»¶
function showTab(tabName) {
    // æ·»åŠ å®‰å…¨æ£€æŸ¥å’Œæ›´å¥½çš„é”™è¯¯å¤„ç†
    try {
        if (window.webInterface && window.webInterface.showTab) {
            window.webInterface.showTab(tabName);
        } else {
            console.warn('WebInterface not ready yet, retrying in 100ms...');
            // å¦‚æœwebInterfaceè¿˜æ²¡å‡†å¤‡å¥½ï¼Œå»¶è¿Ÿé‡è¯•
            setTimeout(() => showTab(tabName), 100);
        }
    } catch (error) {
        console.error('Error in showTab:', error);
    }
}

// éšè—æŒ‚èµ·è¯·æ±‚è­¦å‘Š
function hideSuspendedAlert() {
    const alertBanner = document.getElementById('group-suspended-alert');
    if (alertBanner) {
        alertBanner.style.display = 'none';
    }
}

// é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
window.addEventListener('beforeunload', () => {
    if (window.webInterface) {
        window.webInterface.destroy();
    }
});

// åˆå§‹åŒ–Webç•Œé¢
document.addEventListener('DOMContentLoaded', () => {
    console.log('ğŸ”„ DOMå†…å®¹å·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–WebInterface...');
    try {
        window.webInterface = new WebInterface();
        console.log('âœ… WebInterfaceåˆå§‹åŒ–æˆåŠŸ');
        
        // éªŒè¯showTabå‡½æ•°æ˜¯å¦å¯ç”¨
        if (typeof window.webInterface.showTab === 'function') {
            console.log('âœ… showTabæ–¹æ³•å¯ç”¨');
        } else {
            console.error('âŒ showTabæ–¹æ³•ä¸å¯ç”¨');
        }
    } catch (error) {
        console.error('âŒ WebInterfaceåˆå§‹åŒ–å¤±è´¥:', error);
    }
});